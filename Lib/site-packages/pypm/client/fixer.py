# Copyright (c) 2009 ActiveState Software Inc.
# See http://www.activestate.com/activepython/license-agreement for licensing
# information.

from __future__ import unicode_literals

import os
import sys
import logging

import six

from pypm.common.util import concise_path
from pypm.client.base import ImagePythonEnvironment
from pypm.client.fs import Extractor

if not six.PY3:
    from codecs import open

LOG = logging.getLogger(__name__)


class Fixer:
    
    def __init__(self, pypmenv):
        self.pypmenv = pypmenv

    class ScriptShebangFixer(object):
        """Fix #! hardcoding in scripts

        While running ``easy_install $pkg.name`` is `one solution`_, it will not
        work with packages that use only distutils (not setuptools).

        Note: On Windows, foo.exe uses the shebang line from foo-script.py; so
        we should run this fixer on Windows too.

        .. _`one solution`:
        http://mail.python.org/pipermail/distutils-sig/2008-April/009283.html
        """

        def __init__(self, pypmenv, ipkg):
            self.pypmenv = pypmenv
            self.ipkg = ipkg

            assert os.path.exists(self.pypmenv.pyenv.python_exe)

        @staticmethod
        def applicable():
            return True

        def fix(self):
            pyenv = self.pypmenv.pyenv
            if isinstance(pyenv, ImagePythonEnvironment):
                python_exe = pyenv.target_python_exe
                LOG.info('using ImagePythonEnvironment w/ target=%s', python_exe)
            else:
                python_exe = pyenv.python_exe
                
            scripts_dir = os.path.relpath(
                pyenv.get_install_scheme_path('scripts'),
                pyenv.base_dir)
            binary_exts = ('.exe', '.dll')

            for path in self.ipkg.files_list:
                if path.startswith(scripts_dir) and \
                   path != scripts_dir and \
                   not path.lower().endswith(binary_exts):
                    self._fix_script(pyenv.get_abspath(path), python_exe)
                else:
                    # Just a sanity check to make sure that we didn't break our
                    # earlier behaviour (<=2.6.5.13) by using `get_install_scheme_path`
                    assert not all([any([path.startswith('bin/'),
                                         path.startswith('Scripts/')]),
                                    not path.lower().endswith(binary_exts)]), \
                            "'%s' seems like a script, but does not belong to " \
                            "your the scripts install scheme (%s)" % (
                                path, scripts_dir)

        @staticmethod
        def _fix_script(script_path, python_exe):
            """replace old #! path with ``python_exe``"""
            # read in 'byte' mode and see if the first two chars are #!; if not
            # return immediately to avoid failing with binary files.
            with open(script_path, 'rb') as file:
                if file.read(2) != b'#!':
                    return
                
            with open(script_path, encoding='utf-8') as file:
                content = file.read()
                
            if not content:
                return
                
            first_line = content.splitlines()[0].strip()
            assert first_line.startswith('#!')
            # HACK: guess Python shebang (apart from, say, /bin/sh)
            if 'python' in first_line.lower():
                shebang = '#!' + python_exe
                LOG.info('Fixing script %s', concise_path(script_path))
                LOG.debug('Replacing shebang "%s" with "%s"',
                          first_line, shebang)
                content = content.replace(first_line, shebang)
                with open(script_path, 'w', encoding='utf-8') as file:
                    file.write(content)

        def __str__(self):
            return "<ScriptShebangFixer:%s,%s>" % (self.ipkg.name,
                                                   self.pypmenv.pyenv.root_dir)

    available_fixers = [ScriptShebangFixer]

    def get_applicable_fixers(self, ipkg):
        return [Fixer(self.pypmenv, ipkg)
                for Fixer in self.available_fixers if Fixer.applicable()]

